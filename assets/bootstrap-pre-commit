#!/usr/bin/env bash
# Generate a repo-specific GOD pre-commit hook.
# - Auto-detects component roots from existing <component>/GOD.md docs
# - Falls back to heuristic directory detection
# - Supports interactive confirmation/override

set -euo pipefail

usage() {
  cat <<USAGE
Usage: $(basename "$0") [options]

Options:
  --repo-root <path>         Repository root to bootstrap (default: git root or cwd)
  --hooks-dir <path>         Hooks directory relative to repo root (default: .githooks)
  --components <csv>         Comma-separated component roots (skip auto-detect)
  --yes                      Non-interactive mode (accept detected values)
  --help                     Show this help

Examples:
  $(basename "$0")
  $(basename "$0") --yes
  $(basename "$0") --components "api,worker,web"
  $(basename "$0") --repo-root /path/to/repo --hooks-dir .git/hooks --yes
USAGE
}

REPO_ROOT=""
HOOKS_DIR=".githooks"
COMPONENTS_CSV=""
ASSUME_YES=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --repo-root)
      REPO_ROOT="$2"
      shift 2
      ;;
    --hooks-dir)
      HOOKS_DIR="$2"
      shift 2
      ;;
    --components)
      COMPONENTS_CSV="$2"
      shift 2
      ;;
    --yes)
      ASSUME_YES=1
      shift
      ;;
    --help|-h)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage
      exit 1
      ;;
  esac
done

if [[ -z "$REPO_ROOT" ]]; then
  if git_root=$(git rev-parse --show-toplevel 2>/dev/null); then
    REPO_ROOT="$git_root"
  else
    REPO_ROOT="$(pwd)"
  fi
fi

REPO_ROOT="$(cd "$REPO_ROOT" && pwd)"
cd "$REPO_ROOT"

normalize_components() {
  awk 'NF {gsub(/^ +| +$/, "", $0); if ($0 != "") print $0}' | awk '!seen[$0]++'
}

parse_csv_components() {
  local csv="$1"
  printf '%s' "$csv" | tr ',' '\n' | normalize_components
}

detect_from_god_docs() {
  find . -mindepth 2 -maxdepth 2 -type f -name GOD.md 2>/dev/null \
    | sort \
    | while IFS= read -r path; do
        local rel="${path#./}"
        local root="${rel%/GOD.md}"
        case "$root" in
          docs|docs/*) continue ;;
        esac
        printf '%s\n' "$root"
      done
}

detect_heuristic_roots() {
  local dir
  for dir in */; do
    dir="${dir%/}"
    case "$dir" in
      .git|.github|.vscode|docs|node_modules|vendor|dist|build|target|tmp|temp|coverage)
        continue
        ;;
    esac

    if find "$dir" -type f ! -name GOD.md -print -quit 2>/dev/null | grep -q .; then
      printf '%s\n' "$dir"
    fi
  done
}

collect_components() {
  if [[ -n "$COMPONENTS_CSV" ]]; then
    parse_csv_components "$COMPONENTS_CSV"
    return
  fi

  detect_from_god_docs | normalize_components
}

COMPONENTS="$(collect_components || true)"
SUGGESTED_COMPONENTS=""

if [[ -z "$COMPONENTS" ]]; then
  SUGGESTED_COMPONENTS="$(detect_heuristic_roots | normalize_components || true)"
fi

if [[ -z "$COMPONENTS" && $ASSUME_YES -eq 1 ]]; then
  echo "No component roots detected from existing <component>/GOD.md files." >&2
  echo "Provide --components in non-interactive mode." >&2
  exit 1
fi

if [[ $ASSUME_YES -eq 0 ]]; then
  echo "Detected component roots:"
  if [[ -n "$COMPONENTS" ]]; then
    while IFS= read -r component; do
      echo "  - $component"
    done <<< "$COMPONENTS"
  else
    echo "  (none detected)"
    if [[ -n "$SUGGESTED_COMPONENTS" ]]; then
      echo ""
      echo "Heuristic suggestions:"
      while IFS= read -r component; do
        echo "  - $component"
      done <<< "$SUGGESTED_COMPONENTS"
    fi
  fi

  echo ""
  if [[ -n "$SUGGESTED_COMPONENTS" ]]; then
    read -r -p "Enter comma-separated component roots (press Enter to use heuristic suggestions): " user_components
  else
    read -r -p "Enter comma-separated component roots: " user_components
  fi
  if [[ -n "$user_components" ]]; then
    COMPONENTS="$(parse_csv_components "$user_components")"
  elif [[ -z "$COMPONENTS" ]]; then
    COMPONENTS="$SUGGESTED_COMPONENTS"
  fi

  if [[ -z "$COMPONENTS" ]]; then
    echo "At least one component root is required to generate the hook." >&2
    exit 1
  fi

  echo ""
  echo "Will generate hook with these component roots:"
  while IFS= read -r component; do
    echo "  - $component"
  done <<< "$COMPONENTS"

  read -r -p "Proceed? [Y/n]: " proceed
  case "$proceed" in
    ""|Y|y|yes|YES) ;;
    *)
      echo "Aborted."
      exit 1
      ;;
  esac
fi

HOOKS_PATH="$REPO_ROOT/$HOOKS_DIR"
HOOK_PATH="$HOOKS_PATH/pre-commit"
mkdir -p "$HOOKS_PATH"

{
  cat <<'HEADER'
#!/usr/bin/env bash
# Generated by assets/bootstrap-pre-commit
# Repo-specific GOD doc freshness check.

set -euo pipefail

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

COMPONENT_ROOTS=(
HEADER

  while IFS= read -r component; do
    printf '  %q\n' "$component"
  done <<< "$COMPONENTS"

  cat <<'FOOTER'
)

array_contains() {
  local needle="$1"
  shift || true
  local item
  for item in "$@"; do
    if [[ "$item" == "$needle" ]]; then
      return 0
    fi
  done
  return 1
}

match_component() {
  local file="$1"
  local best=""
  local root
  for root in "${COMPONENT_ROOTS[@]}"; do
    if [[ "$file" == "$root" || "$file" == "$root/"* ]]; then
      if [[ -z "$best" || ${#root} -gt ${#best} ]]; then
        best="$root"
      fi
    fi
  done
  printf '%s' "$best"
}

echo -e "${GREEN}[GOD Hook]${NC} Checking staged changes..."

CHANGED_FILES="$(git diff --cached --name-only --diff-filter=ACMR)"
if [[ -z "$CHANGED_FILES" ]]; then
  echo -e "${GREEN}[GOD Hook]${NC} No staged file additions/modifications/renames."
  exit 0
fi

SOURCE_CHANGED=()
GOD_CHANGED=()
STALE_DOCS=()

while IFS= read -r file; do
  [[ -n "$file" ]] || continue
  component="$(match_component "$file")"
  [[ -n "$component" ]] || continue

  if [[ "$file" == "$component/GOD.md" ]]; then
    if ! array_contains "$component" "${GOD_CHANGED[@]}"; then
      GOD_CHANGED+=("$component")
    fi
  else
    if ! array_contains "$component" "${SOURCE_CHANGED[@]}"; then
      SOURCE_CHANGED+=("$component")
    fi
  fi
done <<< "$CHANGED_FILES"

for component in "${SOURCE_CHANGED[@]}"; do
  if [[ ! -f "$component/GOD.md" ]]; then
    continue
  fi
  if array_contains "$component" "${GOD_CHANGED[@]}"; then
    continue
  fi

  doc="$component/GOD.md"
  if ! array_contains "$doc" "${STALE_DOCS[@]}"; then
    STALE_DOCS+=("$doc")
  fi
done

if [[ ${#STALE_DOCS[@]} -eq 0 ]]; then
  echo -e "${GREEN}[GOD Hook]${NC} No stale GOD docs detected."
  exit 0
fi

echo -e "${YELLOW}[GOD Hook]${NC} Potentially stale GOD docs:"
for doc in "${STALE_DOCS[@]}"; do
  echo "  - $doc"
done

echo ""
echo -e "${YELLOW}[GOD Hook]${NC} Source files changed without corresponding GOD doc updates."
echo "Choose an option:"
echo "  [1] Update docs now (abort commit)"
echo "  [2] Continue commit anyway"
echo "  [3] Abort commit"
read -r -p "Choice [1/2/3]: " choice

case "$choice" in
  1)
    echo -e "${YELLOW}[GOD Hook]${NC} Commit stopped. Update/stage the listed docs, then re-commit."
    exit 1
    ;;
  2)
    echo -e "${YELLOW}[GOD Hook]${NC} Continuing without GOD doc updates."
    exit 0
    ;;
  3)
    echo -e "${RED}[GOD Hook]${NC} Commit aborted."
    exit 1
    ;;
  *)
    echo -e "${RED}[GOD Hook]${NC} Invalid choice. Commit aborted."
    exit 1
    ;;
esac
FOOTER
} > "$HOOK_PATH"

chmod +x "$HOOK_PATH"

echo "Generated: $HOOK_PATH"

if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
  if [[ $ASSUME_YES -eq 1 ]]; then
    git config core.hooksPath "$HOOKS_DIR"
    echo "Configured git hooks path: $HOOKS_DIR"
  else
    read -r -p "Set git config core.hooksPath to '$HOOKS_DIR'? [Y/n]: " set_path
    case "$set_path" in
      ""|Y|y|yes|YES)
        git config core.hooksPath "$HOOKS_DIR"
        echo "Configured git hooks path: $HOOKS_DIR"
        ;;
      *)
        echo "Skipped git config update."
        ;;
    esac
  fi
else
  echo "Not inside a git worktree. Skipped git config update."
fi

echo "Bootstrap complete."
